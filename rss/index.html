<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="https://purl.org/dc/elements/1.1/" xmlns:content="https://purl.org/rss/1.0/modules/content/" xmlns:atom="https://www.w3.org/2005/Atom" version="2.0" xmlns:media="https://search.yahoo.com/mrss/"><channel><title><![CDATA[Untitled RSS Feed]]></title><description><![CDATA[Swift


The programming language]]></description><link>https://swift.madnik.space/</link><generator>Ghost 0.8</generator><lastBuildDate>Wed, 29 Jun 2016 01:37:57 GMT</lastBuildDate><atom:link href="https://swift.madnik.space/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[I'm Swift function. I have many faces - Default parameter values]]></title><description><![CDATA[<h2 id="defaultparametervalues">Default Parameter Values</h2>

<p>Swift functions can have default parameter values. This is done by assigning a parameter value after the type.</p>

<pre><code class="language-swift">func show(animated: Bool = true){  
    if (animated){
        //Animation Code
    }
} 
</code></pre>

<p>The best piece is you can omit parameters with default values in function call. Cool.</p>

<pre><code class="language-swift">show() //Same as show(true)</code></pre>]]></description><link>https://swift.madnik.space/im-swift-function-i-have-many-faces-2/</link><guid isPermaLink="false">3c196be4-42e5-496d-a8bc-a7620abeb5ec</guid><dc:creator><![CDATA[Madushan]]></dc:creator><pubDate>Tue, 28 Jun 2016 11:02:19 GMT</pubDate><content:encoded><![CDATA[<h2 id="defaultparametervalues">Default Parameter Values</h2>

<p>Swift functions can have default parameter values. This is done by assigning a parameter value after the type.</p>

<pre><code class="language-swift">func show(animated: Bool = true){  
    if (animated){
        //Animation Code
    }
} 
</code></pre>

<p>The best piece is you can omit parameters with default values in function call. Cool.</p>

<pre><code class="language-swift">show() //Same as show(true)  
</code></pre>

<p>if you want to call the function with non-default value.</p>

<pre><code class="language-swift">show(false)  
</code></pre>

<p>When it comes to multi parameter functions. <br>
For example:</p>

<pre><code class="language-swift">func start(airConditionOn: Bool = true,lightsOn: Bool = false, headLightsOn: Bool, playMusic: Bool, wiserSpeed: Int = 0){

}
</code></pre>

<p>you can call this method in many possible ways. Many face functions. ðŸ‘»</p>

<pre><code class="language-swift">start(headLightsOn: false, playMusic: false)  
start(lightsOn: false, headLightsOn: true, playMusic: true, wiserSpeed: 3)  
start(false, headLightsOn: true, playMusic: false, wiserSpeed: 2)  
</code></pre>

<p>As you can see this can be confusing sometimes. Apple documentation has recommendation to make this less clutter. </p>

<blockquote>
  <p>Place parameters with default values at the end of a functionâ€™s parameter list. This ensures that all calls to the function use the same order for their nondefault arguments, and makes it clear that the same function is being called in each case.</p>
</blockquote>

<p>i.e</p>

<p>Bring to 2 parameters <strong><code>playMusic</code></strong> and <strong><code>headLightsOn</code></strong> to the front. Because they have to be provided anyway. </p>

<pre><code class="language-swift">func start(playMusic: Bool, headLightsOn: Bool,airConditionOn: Bool = true,lightsOn: Bool = false, wiserSpeed: Int = 0){

}
</code></pre>]]></content:encoded></item><item><title><![CDATA[Some questions about Enums . ??]]></title><description><![CDATA[<p>Check weather you digest the reasons for following enumerations become valid or invalid.</p>

<script src="https://gist.github.com/madnik/143e19f4509772ae418f.js"></script>]]></description><link>https://swift.madnik.space/power-of-enums-in-swift-think/</link><guid isPermaLink="false">aa24ea64-6e2f-4d0a-9b16-c4321e315ff8</guid><dc:creator><![CDATA[Madushan]]></dc:creator><pubDate>Sun, 26 Jun 2016 09:20:13 GMT</pubDate><content:encoded><![CDATA[<p>Check weather you digest the reasons for following enumerations become valid or invalid.</p>

<script src="https://gist.github.com/madnik/143e19f4509772ae418f.js"></script>]]></content:encoded></item><item><title><![CDATA[Power of Swift Enums - 01]]></title><description><![CDATA[<p>Enumerations in swift are much more flexible than enums in many other programming languages. The highlights of Swift enums are,</p>

<ul>
<li>You do not have to provide a value for each member of the enumeration.</li>
<li>If a value is provided it can be a string, a character, or a value of</li></ul>]]></description><link>https://swift.madnik.space/power-of-swift-enums/</link><guid isPermaLink="false">7332195d-9112-43b0-b09a-0a0b4d581fd1</guid><dc:creator><![CDATA[Madushan]]></dc:creator><pubDate>Sun, 26 Jun 2016 09:18:21 GMT</pubDate><content:encoded><![CDATA[<p>Enumerations in swift are much more flexible than enums in many other programming languages. The highlights of Swift enums are,</p>

<ul>
<li>You do not have to provide a value for each member of the enumeration.</li>
<li>If a value is provided it can be a string, a character, or a value of any integer or floating-point type.</li>
<li>Members can specify associated value of any type to store along with the member value.</li>
</ul>

<p>Enumeration syntax</p>

<pre><code class="language-swift">enum SwiftEnumeration {  
    //enumeration definition goes here
}
</code></pre>

<p>Example</p>

<pre><code class="language-swift">enum Gender {  
    case Male
    case Female
}
</code></pre>

<p>Unlike ObjectiveC, <code>Male</code>, <code>Female</code> does not implicitly equal to 0,1. Instead they are values in their own right, with an explicitly defined type of <strong>Gender</strong>.</p>

<blockquote>
  <p>Convention: Enumeration names should start with a capital letter. Give enumeration types singular name.</p>
</blockquote>

<p>Members can be defined in a single line using comma separated values.</p>

<pre><code class="language-swift">enum Planet {  
    case Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune
}
</code></pre>

<p><strong>[Snippet and Explain]</strong></p>

<pre><code class="language-swift">var gender = Gender.Male

//Once assigned we can use short hand syntax
gender = .Female  
</code></pre>

<p>The type of <code>gender</code> is inferred to be <code>Gender</code> once initialized with one of the possible values. There after you can use short hand syntax. Type is not necessary.</p>

<h3 id="associatedvalues">Associated Values</h3>

<p>Swift Enumerations can store associated values of other types alongside with member values. </p>

<pre><code class="language-swift">enum Cipher {  
    case md5(NSString)
    case sha1(NSString)
}
</code></pre>

<p>Above code defines a enumeration type called Cipher which can take either a value of Hash of Sha1 with an associated value of type <code>NSString</code>. <br>
The definition doesn't initialize any NSString value. It just defines type of associated value to use with Cipher.</p>

<p>Lets create a Hash Cipher.</p>

<pre><code class="language-swift">var hashcipher = Cipher.md5(""8743b52063cd84097a65d1633f5c74f5"")  
</code></pre>

<h3 id="rawvalues">Raw Values</h3>

<p>As an alternative to associated values enumeration member can come pre-populated defaults values. Those are called raw values and have to of same type. <br>
Lets consider the example in official swift documentation.</p>

<pre><code class="language-swift">enum ASCIIControlCharacter: Character {  
    case Tab = ""\t""
    case LineFeed = ""\n""
    case CarriageReturn = ""\r""
}
</code></pre>

<p>Here raw values of the enumeration called <code>ASCIIControlCharacter</code> are defined to be of type <code>Character</code>. Here are some rules applicable for raw values.</p>

<ul>
<li>Raw value of particular enumeration member have to always same. Unlike associated values.</li>
<li>Each ray value must be unique within enumeration declaration.</li>
<li>Raw value can be of type String, Character, or any of integer, floating-point number types."</li>
</ul>]]></content:encoded></item><item><title><![CDATA[Swift Tuple and Types]]></title><description><![CDATA[<p>Tuple made it into headlines when the swift was announced. Functions got the ability can return multiple values with help of tuples. What is this tuple. <br>
We will look how tuples fit into Swift type system.</p>

<p>Swift type system divided into 2 categories.</p>

<ul>
<li>names types - Types that given a</li></ul>]]></description><link>https://swift.madnik.space/swift-tuple-and-types/</link><guid isPermaLink="false">c3659911-6d9c-43ab-a3c3-102128921690</guid><dc:creator><![CDATA[Madushan]]></dc:creator><pubDate>Sun, 26 Jun 2016 07:51:09 GMT</pubDate><content:encoded><![CDATA[<p>Tuple made it into headlines when the swift was announced. Functions got the ability can return multiple values with help of tuples. What is this tuple. <br>
We will look how tuples fit into Swift type system.</p>

<p>Swift type system divided into 2 categories.</p>

<ul>
<li>names types - Types that given a name when defined.</li>
<li>compound types - Simply type without names.</li>
</ul>

<p>Tuple is a compound type. For example</p>

<pre><code class="language-swift">(Int, Int)
</code></pre>

<p>Tuple is list of comma separated values, which enclose in parentheses. Tuple can also be contained with zero values. </p>

<pre><code class="language-swift    ">()
</code></pre>

<p>This is an Empty Tuple. <code>Void</code> is a <code>typealias</code> for empty tuple. <br>
Well that is this <code>typealias</code>. </p>

<h1 id="whatistypealias">What is typealias</h1>

<p>Type Alias is a given type name for existing named or compound type in swift. <br>
After defined alias name can be used instead of existing named or compound type.</p>

<pre><code class="language-swift">typealias Point = (Int, Int)  
</code></pre>

<p>In above example <code>Point</code> becomes a aliased type for existing tuple type of <code>(Int, Int)</code>. This is very handy for compound types like tuples.</p>

<h1 id="functionswithmultiplereturnvalues">Functions with Multiple Return Values</h1>

<p>Lets look at an example of function returning multiple values thanks to Tuples.</p>

<pre><code class="language-swift">func getTime() -&gt; (Int, Int, Int) {

    //Calculating Date components. 
    let date = NSDate()
    let calendar = NSCalendar.currentCalendar()
    let components = calendar.components(.CalendarUnitHour | .CalendarUnitMinute | .CalendarUnitSecond, fromDate: date)
    let hours = components.hour
    let minutes = components.minute
    let seconds = components.second

    return ( hours, minutes, seconds)
}
</code></pre>

<p>If you don't understand calculating dates components. Just focus on how to tuple to return multiple values of Hour, Minutes and Seconds. <br>
If you call</p>

<pre><code class="language-swift">let time = getTime()  
</code></pre>

<p>Returns - <code>(.0 18, .1 17, .2 50)</code>. <br>
Values will be different for you as you call this on a different date. <br>
Individual member values of the tuple can be accessed using,</p>

<pre><code class="language-swift">time.0  
time.1  
time.2  
</code></pre>

<p>Member are named using there index of appearance.  What if we want more proper name for elements. <br>
Tuple member values can be named as part of function return type.</p>

<pre><code class="language-swift">func getTime() -&gt; (hours: Int, minutes:  Int, seconds: Int) {  
    ...
    return ( hours, minutes, seconds)
}
</code></pre>

<p>Now the tuple named members can be accessed as follows.</p>

<pre><code class="language-swift">let time = getTime()  
time.hours  
time.minutes  
time.hours  
</code></pre>]]></content:encoded></item><item><title><![CDATA[Lets iterate an swift array while filtering nil elements.]]></title><description><![CDATA[Iterate an swift array skipping nil elements with swift pattern matching power.]]></description><link>https://swift.madnik.space/lets-iterate-an-swift-array-while-filtering-nil-elements/</link><guid isPermaLink="false">6f0542ef-bcf1-4cb0-b956-3078135d93ca</guid><dc:creator><![CDATA[Madushan]]></dc:creator><pubDate>Sun, 26 Jun 2016 07:23:12 GMT</pubDate><content:encoded><![CDATA[<h2 id="anotherpatternmatchingusage">Another Pattern Matching Usage</h2>

<p>Swift <code>Pattern Matching</code> is great. Which enables ton of possibilities which would have ended up in nested branches in <code>ObjectiveC</code></p>

<p>Here is a very simple example of how to iterating an array skipping nil elements in swift.</p>

<pre><code class="language-swift">let arrayOfOptionalInts: [Int?] = [nil, 2, 3, nil, 5]  
// Match only non-nil values
for case let number? in arrayOfOptionalInts{  
    print("Found a Int : \(number)")
}
</code></pre>

<p>So as you can see this is possible thanks to power of pattern matching. Without such power it would have been something like.</p>

<pre><code class="language-swift">for element in arrayOfOptionalInts{  
    if let int = element{
        print("Foun a Int: \(int)")
    }
}
</code></pre>

<p>It can be even this.</p>

<pre><code class="language-swift">let arrayOfTuples: [(Int?,Int?)] = [(nil,1),(1,3),(nil,nil)]

for case let (x?,y?) in arrayOfTuples{  
    print("Found non nil (Int,Int) Tuple: (\(x),\(y))")
}
</code></pre>]]></content:encoded></item></channel></rss>
